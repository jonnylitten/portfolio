<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topology Morpher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000 100%);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            cursor: grab;
        }
        
        body:active {
            cursor: grabbing;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            font-size: 11px;
            backdrop-filter: blur(10px);
            z-index: 100;
            min-width: 250px;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        .control-label {
            display: block;
            color: #6495ff;
            margin-bottom: 5px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(100, 150, 255, 0.2);
            outline: none;
            border-radius: 2px;
            margin: 5px 0;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #6495ff;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            background: #80aaff;
            transform: scale(1.2);
        }
        
        .slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #6495ff;
            cursor: pointer;
            border-radius: 50%;
        }
        
        .value-display {
            float: right;
            color: #80aaff;
            font-size: 10px;
        }
        
        .surface-selector {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
        .surface-btn {
            flex: 1;
            padding: 6px;
            background: rgba(100, 150, 255, 0.1);
            border: 1px solid rgba(100, 150, 255, 0.3);
            color: #80aaff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 10px;
            transition: all 0.3s;
        }
        
        .surface-btn:hover {
            background: rgba(100, 150, 255, 0.2);
            border-color: rgba(100, 150, 255, 0.5);
        }
        
        .surface-btn.active {
            background: rgba(100, 150, 255, 0.3);
            border-color: #6495ff;
            color: #fff;
        }
        
        .audio-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            font-size: 11px;
            backdrop-filter: blur(10px);
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .audio-status:hover {
            background: rgba(100, 150, 255, 0.1);
            border-color: rgba(100, 150, 255, 0.5);
        }
        
        .audio-status.active {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
        }
        
        .equation-display {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            color: rgba(100, 150, 255, 0.8);
            backdrop-filter: blur(10px);
            max-width: 400px;
        }
        
        .curvature-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            font-size: 10px;
            backdrop-filter: blur(10px);
            text-align: right;
        }
        
        .curvature-value {
            color: #6495ff;
            font-size: 14px;
            margin-top: 5px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label class="control-label">
                Morphing α
                <span class="value-display" id="morphValue">0.00</span>
            </label>
            <input type="range" class="slider" id="morphSlider" min="0" max="100" value="0">
        </div>
        
        <div class="control-group">
            <label class="control-label">
                Deformation β
                <span class="value-display" id="deformValue">0.00</span>
            </label>
            <input type="range" class="slider" id="deformSlider" min="-100" max="100" value="0">
        </div>
        
        <div class="control-group">
            <label class="control-label">
                Time Flow τ
                <span class="value-display" id="timeValue">1.00</span>
            </label>
            <input type="range" class="slider" id="timeSlider" min="0" max="200" value="100">
        </div>
        
        <div class="control-group">
            <label class="control-label">Surface Type</label>
            <div class="surface-selector">
                <button class="surface-btn active" data-surface="torus">Torus</button>
                <button class="surface-btn" data-surface="sphere">Sphere</button>
                <button class="surface-btn" data-surface="klein">Klein</button>
            </div>
        </div>
    </div>
    
    <div class="audio-status" id="audioStatus">
        🔊 Click to Enable Audio
    </div>
    
    <div class="equation-display" id="equation">
        x(u,v) = (R + r·cos(v))·cos(u)<br>
        y(u,v) = (R + r·cos(v))·sin(u)<br>
        z(u,v) = r·sin(v)
    </div>
    
    <div class="curvature-indicator">
        <div style="color: rgba(255, 255, 255, 0.5)">Gaussian Curvature K</div>
        <div class="curvature-value" id="curvatureValue">0.00</div>
    </div>
    
    <canvas id="topologyCanvas"></canvas>
    
    <script>
        class TopologyMorpher {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('topologyCanvas'),
                    antialias: true,
                    alpha: true
                });
                
                this.audioContext = null;
                this.audioEnabled = false;
                this.oscillators = [];
                this.gainNodes = [];
                this.masterGain = null;
                
                this.morphValue = 0;
                this.deformValue = 0;
                this.timeFlow = 1;
                this.surfaceType = 'torus';
                
                this.mouse = { x: 0, y: 0, down: false };
                this.rotation = { x: 0, y: 0 };
                
                this.mesh = null;
                this.wireframe = null;
                this.particles = null;
                
                this.time = 0;
                
                this.init();
            }
            
            init() {
                // Renderer setup
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                
                // Camera position
                this.camera.position.z = 5;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
                this.scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0x6495ff, 1, 100);
                pointLight.position.set(5, 5, 5);
                this.scene.add(pointLight);
                
                const pointLight2 = new THREE.PointLight(0xff6495, 0.5, 100);
                pointLight2.position.set(-5, -5, 5);
                this.scene.add(pointLight2);
                
                // Create initial surface
                this.createSurface();
                
                // Event listeners
                this.setupEventListeners();
                
                // Start animation
                this.animate();
            }
            
            setupEventListeners() {
                // Mouse controls
                document.addEventListener('mousedown', (e) => {
                    this.mouse.down = true;
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });
                
                document.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.down) {
                        const deltaX = e.clientX - this.mouse.x;
                        const deltaY = e.clientY - this.mouse.y;
                        
                        this.rotation.y += deltaX * 0.01;
                        this.rotation.x += deltaY * 0.01;
                        
                        this.mouse.x = e.clientX;
                        this.mouse.y = e.clientY;
                    }
                });
                
                // Touch controls for mobile
                document.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        this.mouse.down = true;
                        this.mouse.x = e.touches[0].clientX;
                        this.mouse.y = e.touches[0].clientY;
                    }
                });
                
                document.addEventListener('touchend', () => {
                    this.mouse.down = false;
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (this.mouse.down && e.touches.length === 1) {
                        const deltaX = e.touches[0].clientX - this.mouse.x;
                        const deltaY = e.touches[0].clientY - this.mouse.y;
                        
                        this.rotation.y += deltaX * 0.01;
                        this.rotation.x += deltaY * 0.01;
                        
                        this.mouse.x = e.touches[0].clientX;
                        this.mouse.y = e.touches[0].clientY;
                    }
                });
                
                // Slider controls
                document.getElementById('morphSlider').addEventListener('input', (e) => {
                    this.morphValue = e.target.value / 100;
                    document.getElementById('morphValue').textContent = this.morphValue.toFixed(2);
                    this.updateSurface();
                });
                
                document.getElementById('deformSlider').addEventListener('input', (e) => {
                    this.deformValue = e.target.value / 100;
                    document.getElementById('deformValue').textContent = this.deformValue.toFixed(2);
                    this.updateSurface();
                });
                
                document.getElementById('timeSlider').addEventListener('input', (e) => {
                    this.timeFlow = e.target.value / 100;
                    document.getElementById('timeValue').textContent = this.timeFlow.toFixed(2);
                });
                
                // Surface type buttons
                document.querySelectorAll('.surface-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.surface-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.surfaceType = btn.dataset.surface;
                        this.updateEquation();
                        this.createSurface();
                    });
                });
                
                // Audio enable
                document.getElementById('audioStatus').addEventListener('click', () => {
                    this.toggleAudio();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            async toggleAudio() {
                const status = document.getElementById('audioStatus');
                
                if (!this.audioEnabled) {
                    await this.initAudio();
                    status.textContent = '🔊 Audio Enabled';
                    status.classList.add('active');
                    this.audioEnabled = true;
                } else {
                    this.stopAudio();
                    status.textContent = '🔊 Click to Enable Audio';
                    status.classList.remove('active');
                    this.audioEnabled = false;
                }
            }
            
            async initAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master gain
                this.masterGain = this.audioContext.createGain();
                this.masterGain.gain.setValueAtTime(0.05, this.audioContext.currentTime);
                
                // Create reverb
                const convolver = this.audioContext.createConvolver();
                const reverbTime = 2;
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * reverbTime;
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                convolver.buffer = impulse;
                
                // Connect audio chain
                this.masterGain.connect(convolver);
                convolver.connect(this.audioContext.destination);
                this.masterGain.connect(this.audioContext.destination);
                
                // Create oscillator bank
                for (let i = 0; i < 6; i++) {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                    osc.frequency.setValueAtTime(110 * Math.pow(2, i/12), this.audioContext.currentTime);
                    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    
                    this.oscillators.push(osc);
                    this.gainNodes.push(gain);
                }
            }
            
            stopAudio() {
                if (this.audioContext) {
                    this.oscillators.forEach(osc => osc.stop());
                    this.audioContext.close();
                    this.oscillators = [];
                    this.gainNodes = [];
                    this.audioContext = null;
                }
            }
            
            createSurface() {
                // Remove old mesh if exists
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.scene.remove(this.wireframe);
                }
                
                // Create parametric geometry
                const geometry = new THREE.ParametricGeometry(
                    (u, v, target) => this.parametricFunction(u, v, target),
                    64,
                    64
                );
                
                // Main material
                const material = new THREE.MeshPhongMaterial({
                    color: 0x6495ff,
                    specular: 0x222244,
                    shininess: 100,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Create mesh
                this.mesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.mesh);
                
                // Add wireframe
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x304080,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                this.wireframe = new THREE.Mesh(geometry, wireframeMaterial);
                this.scene.add(this.wireframe);
            }
            
            parametricFunction(u, v, target) {
                u = u * 2 * Math.PI;
                v = v * 2 * Math.PI;
                
                let x, y, z;
                const morph = this.morphValue;
                const deform = this.deformValue;
                
                switch (this.surfaceType) {
                    case 'torus':
                        const R = 2 + deform * 0.5;
                        const r = 0.7 + Math.sin(this.time * 0.001) * 0.1;
                        
                        // Morph between torus and twisted torus
                        const twist = morph * 2;
                        
                        x = (R + r * Math.cos(v + twist * u)) * Math.cos(u);
                        y = (R + r * Math.cos(v + twist * u)) * Math.sin(u);
                        z = r * Math.sin(v + twist * u) + deform * Math.sin(u * 3) * 0.3;
                        break;
                        
                    case 'sphere':
                        const radius = 2 + Math.sin(this.time * 0.001) * 0.1;
                        
                        // Morph to ellipsoid
                        const a = radius * (1 + morph * 0.5);
                        const b = radius * (1 - morph * 0.3);
                        const c = radius * (1 + deform * 0.4);
                        
                        x = a * Math.sin(v) * Math.cos(u);
                        y = b * Math.sin(v) * Math.sin(u);
                        z = c * Math.cos(v);
                        
                        // Add ripples
                        const ripple = Math.sin(u * 8 + this.time * 0.002) * Math.sin(v * 8) * 0.1;
                        x += x * ripple * morph;
                        y += y * ripple * morph;
                        z += z * ripple * morph;
                        break;
                        
                    case 'klein':
                        // Klein bottle (figure-8 immersion)
                        const a2 = 2 + deform * 0.5;
                        
                        if (u < Math.PI) {
                            x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 - morph) * Math.cos(u) * Math.cos(v);
                            y = 3 * Math.sin(u) + (2 - morph) * Math.sin(u) * Math.cos(v);
                        } else {
                            x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 - morph) * Math.cos(v + Math.PI);
                            y = 3 * Math.sin(u);
                        }
                        z = (2 - morph) * Math.sin(v);
                        
                        // Scale down
                        x *= 0.4;
                        y *= 0.4;
                        z *= 0.4;
                        break;
                }
                
                target.set(x, y, z);
            }
            
            updateSurface() {
                if (this.mesh) {
                    const geometry = new THREE.ParametricGeometry(
                        (u, v, target) => this.parametricFunction(u, v, target),
                        64,
                        64
                    );
                    
                    this.mesh.geometry.dispose();
                    this.mesh.geometry = geometry;
                    
                    this.wireframe.geometry.dispose();
                    this.wireframe.geometry = geometry;
                    
                    // Calculate and display curvature
                    this.updateCurvature();
                }
            }
            
            updateCurvature() {
                // Simplified Gaussian curvature calculation
                // Real calculation would involve computing the first and second fundamental forms
                const K = Math.cos(this.morphValue * Math.PI) / (2 + Math.abs(this.deformValue));
                document.getElementById('curvatureValue').textContent = K.toFixed(3);
                
                // Update oscillator frequencies based on curvature
                if (this.audioEnabled && this.oscillators.length > 0) {
                    const baseFreq = 110 * (1 + K * 0.5);
                    
                    this.oscillators.forEach((osc, i) => {
                        const targetFreq = baseFreq * Math.pow(2, (i * 7 + this.morphValue * 12) / 12);
                        osc.frequency.exponentialRampToValueAtTime(
                            targetFreq,
                            this.audioContext.currentTime + 0.1
                        );
                        
                        // Set gain based on surface properties
                        const gain = Math.abs(K) * 0.3 * (1 - i / this.oscillators.length);
                        this.gainNodes[i].gain.exponentialRampToValueAtTime(
                            Math.max(0.001, gain),
                            this.audioContext.currentTime + 0.1
                        );
                    });
                }
            }
            
            updateEquation() {
                const equations = {
                    torus: `x(u,v) = (R + r·cos(v))·cos(u)<br>
                            y(u,v) = (R + r·cos(v))·sin(u)<br>
                            z(u,v) = r·sin(v)`,
                    sphere: `x(u,v) = r·sin(v)·cos(u)<br>
                            y(u,v) = r·sin(v)·sin(u)<br>
                            z(u,v) = r·cos(v)`,
                    klein: `Klein bottle immersion<br>
                           ℝ⁴ → ℝ³ projection<br>
                           Non-orientable surface`
                };
                
                document.getElementById('equation').innerHTML = equations[this.surfaceType];
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.time += 16 * this.timeFlow;
                
                // Auto-rotation when not dragging
                if (!this.mouse.down) {
                    this.rotation.y += 0.003 * this.timeFlow;
                }
                
                // Update mesh rotation
                if (this.mesh) {
                    this.mesh.rotation.x = this.rotation.x;
                    this.mesh.rotation.y = this.rotation.y;
                    
                    this.wireframe.rotation.x = this.rotation.x;
                    this.wireframe.rotation.y = this.rotation.y;
                    
                    // Gentle pulsing
                    const scale = 1 + Math.sin(this.time * 0.001) * 0.02;
                    this.mesh.scale.set(scale, scale, scale);
                    this.wireframe.scale.set(scale, scale, scale);
                }
                
                // Update surface if time is flowing
                if (this.timeFlow > 0) {
                    this.updateSurface();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize on page load
        window.addEventListener('load', () => {
            new TopologyMorpher();
        });
    </script>
</body>
</html>